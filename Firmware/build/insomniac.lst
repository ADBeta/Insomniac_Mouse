
build/insomniac.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:

#if defined( CH32V003 ) || defined( CH32X03x )

void InterruptVectorDefault()
{
	asm volatile( "\n\
   0:	3940006f          	j	394 <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	00000406          	.word	0x00000406
   c:	00000404          	.word	0x00000404
	...
  30:	00000404          	.word	0x00000404
  34:	00000000          	.word	0x00000000
  38:	00000404          	.word	0x00000404
  3c:	00000000          	.word	0x00000000
  40:	00000404          	.word	0x00000404
  44:	00000404          	.word	0x00000404
  48:	00000404          	.word	0x00000404
  4c:	00000404          	.word	0x00000404
  50:	00000404          	.word	0x00000404
  54:	00000404          	.word	0x00000404
  58:	00000404          	.word	0x00000404
  5c:	00000404          	.word	0x00000404
  60:	00000404          	.word	0x00000404
  64:	00000404          	.word	0x00000404
  68:	00000404          	.word	0x00000404
  6c:	00000404          	.word	0x00000404
  70:	00000404          	.word	0x00000404
  74:	00000404          	.word	0x00000404
  78:	00000404          	.word	0x00000404
  7c:	00000404          	.word	0x00000404
  80:	00000404          	.word	0x00000404
  84:	00000404          	.word	0x00000404
  88:	00000404          	.word	0x00000404
  8c:	00000404          	.word	0x00000404
  90:	00000404          	.word	0x00000404
  94:	00000404          	.word	0x00000404
  98:	00000404          	.word	0x00000404
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <__divsi3>:
  a0:	02054e63          	bltz	a0,dc <__umodsi3+0x8>
  a4:	0405c363          	bltz	a1,ea <__umodsi3+0x16>

000000a8 <__hidden___udivsi3>:
  a8:	862e                	mv	a2,a1
  aa:	85aa                	mv	a1,a0
  ac:	557d                	li	a0,-1
  ae:	c215                	beqz	a2,d2 <__hidden___udivsi3+0x2a>
  b0:	4685                	li	a3,1
  b2:	00b67863          	bgeu	a2,a1,c2 <__hidden___udivsi3+0x1a>
  b6:	00c05663          	blez	a2,c2 <__hidden___udivsi3+0x1a>
  ba:	0606                	slli	a2,a2,0x1
  bc:	0686                	slli	a3,a3,0x1
  be:	feb66ce3          	bltu	a2,a1,b6 <__hidden___udivsi3+0xe>
  c2:	4501                	li	a0,0
  c4:	00c5e463          	bltu	a1,a2,cc <__hidden___udivsi3+0x24>
  c8:	8d91                	sub	a1,a1,a2
  ca:	8d55                	or	a0,a0,a3
  cc:	8285                	srli	a3,a3,0x1
  ce:	8205                	srli	a2,a2,0x1
  d0:	faf5                	bnez	a3,c4 <__hidden___udivsi3+0x1c>
  d2:	8082                	ret

000000d4 <__umodsi3>:
  d4:	8286                	mv	t0,ra
  d6:	3fc9                	jal	a8 <__hidden___udivsi3>
  d8:	852e                	mv	a0,a1
  da:	8282                	jr	t0
  dc:	40a00533          	neg	a0,a0
  e0:	00b04763          	bgtz	a1,ee <__umodsi3+0x1a>
  e4:	40b005b3          	neg	a1,a1
  e8:	b7c1                	j	a8 <__hidden___udivsi3>
  ea:	40b005b3          	neg	a1,a1
  ee:	8286                	mv	t0,ra
  f0:	3f65                	jal	a8 <__hidden___udivsi3>
  f2:	40a00533          	neg	a0,a0
  f6:	8282                	jr	t0

000000f8 <__modsi3>:
  f8:	8286                	mv	t0,ra
  fa:	0005c763          	bltz	a1,108 <__modsi3+0x10>
  fe:	00054963          	bltz	a0,110 <__modsi3+0x18>
 102:	375d                	jal	a8 <__hidden___udivsi3>
 104:	852e                	mv	a0,a1
 106:	8282                	jr	t0
 108:	40b005b3          	neg	a1,a1
 10c:	fe055be3          	bgez	a0,102 <__modsi3+0xa>
 110:	40a00533          	neg	a0,a0
 114:	3f51                	jal	a8 <__hidden___udivsi3>
 116:	40b00533          	neg	a0,a1
 11a:	8282                	jr	t0
	...

0000011e <mini_pad>:
	if(pad_to == 0) pad_to = len;
 11e:	c699                	beqz	a3,12c <mini_pad+0xe>
	int overflow = 0;
 120:	4301                	li	t1,0
	if(len > pad_to) {
 122:	00b6d763          	bge	a3,a1,130 <mini_pad+0x12>
		len = pad_to;
 126:	85b6                	mv	a1,a3
		overflow = 1;
 128:	4305                	li	t1,1
 12a:	a019                	j	130 <mini_pad+0x12>
	int overflow = 0;
 12c:	4301                	li	t1,0
	if(pad_to == 0) pad_to = len;
 12e:	86ae                	mv	a3,a1
	for(i = pad_to - len; i > 0; i --) {
 130:	8e8d                	sub	a3,a3,a1
	char * pbuffer = buffer;
 132:	87ba                	mv	a5,a4
 134:	00e683b3          	add	t2,a3,a4
	for(i = pad_to - len; i > 0; i --) {
 138:	40f382b3          	sub	t0,t2,a5
 13c:	04504a63          	bgtz	t0,190 <mini_pad+0x72>
 140:	fff6c793          	not	a5,a3
 144:	87fd                	srai	a5,a5,0x1f
 146:	8efd                	and	a3,a3,a5
 148:	96ba                	add	a3,a3,a4
 14a:	4781                	li	a5,0
	for(i = len; i > 0; i --) {
 14c:	40f58633          	sub	a2,a1,a5
 150:	00f682b3          	add	t0,a3,a5
 154:	04c04263          	bgtz	a2,198 <mini_pad+0x7a>
 158:	fff5c793          	not	a5,a1
 15c:	87fd                	srai	a5,a5,0x1f
 15e:	8dfd                	and	a1,a1,a5
 160:	95b6                	add	a1,a1,a3
	len = pbuffer - buffer;
 162:	40e58533          	sub	a0,a1,a4
	if(overflow) {
 166:	02030463          	beqz	t1,18e <mini_pad+0x70>
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 16a:	02b77263          	bgeu	a4,a1,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 16e:	02a00793          	li	a5,42
 172:	fef58fa3          	sb	a5,-1(a1)
 176:	fff58693          	addi	a3,a1,-1
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 17a:	00d77a63          	bgeu	a4,a3,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 17e:	fef58f23          	sb	a5,-2(a1)
 182:	ffe58693          	addi	a3,a1,-2
		for (i = 0; i < 3 && pbuffer > buffer; i ++) {
 186:	00d77463          	bgeu	a4,a3,18e <mini_pad+0x70>
			*(pbuffer-- - 1) = '*';
 18a:	fef58ea3          	sb	a5,-3(a1)
}
 18e:	8082                	ret
		*(pbuffer++) = pad_char;
 190:	0785                	addi	a5,a5,1
 192:	fec78fa3          	sb	a2,-1(a5)
	for(i = pad_to - len; i > 0; i --) {
 196:	b74d                	j	138 <mini_pad+0x1a>
		*(pbuffer++) = *(ptr++);
 198:	00f50633          	add	a2,a0,a5
 19c:	00064603          	lbu	a2,0(a2)
 1a0:	0785                	addi	a5,a5,1
 1a2:	00c28023          	sb	a2,0(t0)
	for(i = len; i > 0; i --) {
 1a6:	b75d                	j	14c <mini_pad+0x2e>

000001a8 <_puts>:
{
 1a8:	832a                	mv	t1,a0
 1aa:	852e                	mv	a0,a1
	if(!buf) return len;
 1ac:	ce01                	beqz	a2,1c4 <_puts+0x1c>
	char * p0 = b->buffer;
 1ae:	00062283          	lw	t0,0(a2)
	for (i = 0; i < len; i++) {
 1b2:	4701                	li	a4,0
		if(b->pbuffer == b->buffer + b->buffer_len - 1) {
 1b4:	425c                	lw	a5,4(a2)
	for (i = 0; i < len; i++) {
 1b6:	00a74863          	blt	a4,a0,1c6 <_puts+0x1e>
	*(b->pbuffer) = 0;
 1ba:	00078023          	sb	zero,0(a5)
	return b->pbuffer - p0;
 1be:	4248                	lw	a0,4(a2)
 1c0:	40550533          	sub	a0,a0,t0
}
 1c4:	8082                	ret
		if(b->pbuffer == b->buffer + b->buffer_len - 1) {
 1c6:	460c                	lw	a1,8(a2)
 1c8:	4214                	lw	a3,0(a2)
 1ca:	15fd                	addi	a1,a1,-1
 1cc:	96ae                	add	a3,a3,a1
 1ce:	fed786e3          	beq	a5,a3,1ba <_puts+0x12>
		*(b->pbuffer ++) = s[i];
 1d2:	00178693          	addi	a3,a5,1
 1d6:	c254                	sw	a3,4(a2)
 1d8:	00e306b3          	add	a3,t1,a4
 1dc:	0006c683          	lbu	a3,0(a3)
	for (i = 0; i < len; i++) {
 1e0:	0705                	addi	a4,a4,1
		*(b->pbuffer ++) = s[i];
 1e2:	00d78023          	sb	a3,0(a5)
	for (i = 0; i < len; i++) {
 1e6:	b7f9                	j	1b4 <_puts+0xc>

000001e8 <mini_itoa.part.0>:
mini_itoa(long value, unsigned int radix, int uppercase, int unsig,
 1e8:	1101                	addi	sp,sp,-32
 1ea:	ce06                	sw	ra,28(sp)
 1ec:	cc22                	sw	s0,24(sp)
 1ee:	ca26                	sw	s1,20(sp)
	int	negative = 0;
 1f0:	c002                	sw	zero,0(sp)
mini_itoa(long value, unsigned int radix, int uppercase, int unsig,
 1f2:	832a                	mv	t1,a0
	if (value < 0 && !unsig) {
 1f4:	00055763          	bgez	a0,202 <mini_itoa.part.0+0x1a>
 1f8:	e689                	bnez	a3,202 <mini_itoa.part.0+0x1a>
		negative = 1;
 1fa:	4785                	li	a5,1
		value = -value;
 1fc:	40a00333          	neg	t1,a0
		negative = 1;
 200:	c03e                	sw	a5,0(sp)
 202:	8a05                	andi	a2,a2,1
 204:	06100413          	li	s0,97
 208:	c219                	beqz	a2,20e <mini_itoa.part.0+0x26>
 20a:	04100413          	li	s0,65
	int	negative = 0;
 20e:	84ba                	mv	s1,a4
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 210:	1459                	addi	s0,s0,-10
		int digit = value % radix;
 212:	851a                	mv	a0,t1
 214:	c83a                	sw	a4,16(sp)
 216:	c21a                	sw	t1,4(sp)
 218:	c62e                	sw	a1,12(sp)
 21a:	c41a                	sw	t1,8(sp)
 21c:	3d65                	jal	d4 <__umodsi3>
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 21e:	47a5                	li	a5,9
 220:	4322                	lw	t1,8(sp)
 222:	45b2                	lw	a1,12(sp)
 224:	4742                	lw	a4,16(sp)
 226:	0ff57693          	zext.b	a3,a0
 22a:	06a7e163          	bltu	a5,a0,28c <mini_itoa.part.0+0xa4>
 22e:	03068693          	addi	a3,a3,48
 232:	0ff6f693          	zext.b	a3,a3
 236:	00148793          	addi	a5,s1,1
 23a:	00d48023          	sb	a3,0(s1)
		value /= radix;
 23e:	851a                	mv	a0,t1
 240:	c83a                	sw	a4,16(sp)
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 242:	c63e                	sw	a5,12(sp)
		value /= radix;
 244:	c42e                	sw	a1,8(sp)
 246:	358d                	jal	a8 <__hidden___udivsi3>
	} while (value > 0);
 248:	4692                	lw	a3,4(sp)
 24a:	45a2                	lw	a1,8(sp)
 24c:	47b2                	lw	a5,12(sp)
 24e:	4742                	lw	a4,16(sp)
		value /= radix;
 250:	832a                	mv	t1,a0
	} while (value > 0);
 252:	02b6fb63          	bgeu	a3,a1,288 <mini_itoa.part.0+0xa0>
	if (negative)
 256:	4682                	lw	a3,0(sp)
 258:	c699                	beqz	a3,266 <mini_itoa.part.0+0x7e>
		*(pbuffer++) = '-';
 25a:	02d00693          	li	a3,45
 25e:	00d78023          	sb	a3,0(a5)
 262:	00248793          	addi	a5,s1,2
	len = (pbuffer - buffer);
 266:	40e78533          	sub	a0,a5,a4
	for (i = 0; i < len / 2; i++) {
 26a:	01f55693          	srli	a3,a0,0x1f
 26e:	96aa                	add	a3,a3,a0
	*(pbuffer) = '\0';
 270:	00078023          	sb	zero,0(a5)
	for (i = 0; i < len / 2; i++) {
 274:	8685                	srai	a3,a3,0x1
 276:	4601                	li	a2,0
 278:	17fd                	addi	a5,a5,-1
 27a:	00d64b63          	blt	a2,a3,290 <mini_itoa.part.0+0xa8>
}
 27e:	40f2                	lw	ra,28(sp)
 280:	4462                	lw	s0,24(sp)
 282:	44d2                	lw	s1,20(sp)
 284:	6105                	addi	sp,sp,32
 286:	8082                	ret
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
 288:	84be                	mv	s1,a5
 28a:	b761                	j	212 <mini_itoa.part.0+0x2a>
 28c:	96a2                	add	a3,a3,s0
 28e:	b755                	j	232 <mini_itoa.part.0+0x4a>
		char j = buffer[i];
 290:	00c705b3          	add	a1,a4,a2
		buffer[i] = buffer[len-i-1];
 294:	0007c283          	lbu	t0,0(a5)
		char j = buffer[i];
 298:	0005c303          	lbu	t1,0(a1)
	for (i = 0; i < len / 2; i++) {
 29c:	0605                	addi	a2,a2,1
		buffer[i] = buffer[len-i-1];
 29e:	00558023          	sb	t0,0(a1)
		buffer[len-i-1] = j;
 2a2:	00678023          	sb	t1,0(a5)
	for (i = 0; i < len / 2; i++) {
 2a6:	bfc9                	j	278 <mini_itoa.part.0+0x90>

000002a8 <internal_handle_input.constprop.0>:
void handle_debug_input( int numbytes, uint8_t * data ) __attribute__((weak));
void handle_debug_input( int numbytes, uint8_t * data ) { (void)numbytes; (void)data; }

static void internal_handle_input( volatile uint32_t * dmdata0 )
{
	uint32_t dmd0 = *dmdata0;
 2a8:	e00007b7          	lui	a5,0xe0000
 2ac:	0f47a783          	lw	a5,244(a5) # e00000f4 <__global_pointer$+0xbffff8f4>
	int bytes = (dmd0 & 0x3f) - 4;
	if( bytes > 0 )
	{
		handle_debug_input( bytes, ((uint8_t*)dmdata0) + 1 );
	}
}
 2b0:	8082                	ret

000002b2 <_write.constprop.0>:
// where [status word] is:
//   b7 = is a "printf" waiting?
//   b0..b3 = # of bytes in printf (+4).  (5 or higher indicates a print of some kind)
//     note: if b7 is 0 in reply, but b0..b3 have >=4 then we received data from host.
// declare as weak to allow overriding.
WEAK int _write(int fd, const char *buf, int size)
 2b2:	1121                	addi	sp,sp,-24
 2b4:	c822                	sw	s0,16(sp)
 2b6:	ca06                	sw	ra,20(sp)
 2b8:	c626                	sw	s1,12(sp)
{
	(void)fd;

	char buffer[4] = { 0 };
 2ba:	c402                	sw	zero,8(sp)
WEAK int _write(int fd, const char *buf, int size)
 2bc:	842e                	mv	s0,a1
	int place = 0;
	uint32_t lastdmd;
	uint32_t timeout = FUNCONF_DEBUGPRINTF_TIMEOUT; // Give up after ~40ms

	if( size == 0 )
 2be:	eddd                	bnez	a1,37c <_write.constprop.0+0xca>
	{
		lastdmd = (*DMDATA0);
 2c0:	e00007b7          	lui	a5,0xe0000
 2c4:	0f47a783          	lw	a5,244(a5) # e00000f4 <__global_pointer$+0xbffff8f4>
		if( lastdmd && !(lastdmd&0x80) ) internal_handle_input( (uint32_t*)DMDATA0 );
 2c8:	c789                	beqz	a5,2d2 <_write.constprop.0+0x20>
 2ca:	0807f793          	andi	a5,a5,128
 2ce:	e391                	bnez	a5,2d2 <_write.constprop.0+0x20>
 2d0:	3fe1                	jal	2a8 <internal_handle_input.constprop.0>

		//buf += tosend;
		place += tosend;
	}
	return size;
}
 2d2:	40d2                	lw	ra,20(sp)
 2d4:	8522                	mv	a0,s0
 2d6:	4442                	lw	s0,16(sp)
 2d8:	44b2                	lw	s1,12(sp)
 2da:	0161                	addi	sp,sp,24
 2dc:	8082                	ret
		int tosend = size - place;
 2de:	409407b3          	sub	a5,s0,s1
		if( tosend > 7 ) tosend = 7;
 2e2:	471d                	li	a4,7
 2e4:	00f75363          	bge	a4,a5,2ea <_write.constprop.0+0x38>
 2e8:	87ba                	mv	a5,a4
 2ea:	00027737          	lui	a4,0x27
		while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 2ee:	e00006b7          	lui	a3,0xe0000
		if( tosend > 7 ) tosend = 7;
 2f2:	10170713          	addi	a4,a4,257 # 27101 <insomniac.c.2101b6a3+0x25342>
		while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 2f6:	0f468693          	addi	a3,a3,244 # e00000f4 <__global_pointer$+0xbffff8f4>
 2fa:	4290                	lw	a2,0(a3)
 2fc:	08067593          	andi	a1,a2,128
 300:	e1a5                	bnez	a1,360 <_write.constprop.0+0xae>
		if( lastdmd ) internal_handle_input( (uint32_t*)DMDATA0 );
 302:	c611                	beqz	a2,30e <_write.constprop.0+0x5c>
 304:	c22a                	sw	a0,4(sp)
 306:	c03e                	sw	a5,0(sp)
 308:	3745                	jal	2a8 <internal_handle_input.constprop.0>
 30a:	4512                	lw	a0,4(sp)
 30c:	4782                	lw	a5,0(sp)
 30e:	0034                	addi	a3,sp,8
		if( tosend > 7 ) tosend = 7;
 310:	470d                	li	a4,3
 312:	85b6                	mv	a1,a3
		while( t < tosend )
 314:	04f74a63          	blt	a4,a5,368 <_write.constprop.0+0xb6>
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 318:	46a2                	lw	a3,8(sp)
 31a:	e0000737          	lui	a4,0xe0000
		while( t < tosend && t < 3 )
 31e:	460d                	li	a2,3
		*DMDATA1 = *(uint32_t*)&(buffer[0]);
 320:	0ed72c23          	sw	a3,248(a4) # e00000f8 <__global_pointer$+0xbffff8f8>
 324:	009506b3          	add	a3,a0,s1
		t = 0;
 328:	4701                	li	a4,0
			buffer[t+1] = buf[t+place];
 32a:	0006c283          	lbu	t0,0(a3)
 32e:	0705                	addi	a4,a4,1
 330:	00e58333          	add	t1,a1,a4
 334:	00530023          	sb	t0,0(t1)
		while( t < tosend && t < 3 )
 338:	00e78563          	beq	a5,a4,342 <_write.constprop.0+0x90>
 33c:	0685                	addi	a3,a3,1
 33e:	fec716e3          	bne	a4,a2,32a <_write.constprop.0+0x78>
		buffer[0] = 0x80 | (tosend + 4);
 342:	00478713          	addi	a4,a5,4
 346:	f8076713          	ori	a4,a4,-128
 34a:	00e10423          	sb	a4,8(sp)
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 34e:	46a2                	lw	a3,8(sp)
 350:	e0000737          	lui	a4,0xe0000
		place += tosend;
 354:	94be                	add	s1,s1,a5
		*DMDATA0 = *(uint32_t*)&(buffer[0]);
 356:	0ed72a23          	sw	a3,244(a4) # e00000f4 <__global_pointer$+0xbffff8f4>
	while( place < size )
 35a:	f884c2e3          	blt	s1,s0,2de <_write.constprop.0+0x2c>
 35e:	bf95                	j	2d2 <_write.constprop.0+0x20>
			if( timeout-- == 0 ) return place;
 360:	177d                	addi	a4,a4,-1
 362:	ff41                	bnez	a4,2fa <_write.constprop.0+0x48>
 364:	8426                	mv	s0,s1
 366:	b7b5                	j	2d2 <_write.constprop.0+0x20>
			buffer[t-3] = buf[t+place];
 368:	00e48633          	add	a2,s1,a4
 36c:	962a                	add	a2,a2,a0
 36e:	00064603          	lbu	a2,0(a2)
			t++;
 372:	0705                	addi	a4,a4,1
 374:	0685                	addi	a3,a3,1
			buffer[t-3] = buf[t+place];
 376:	fec68fa3          	sb	a2,-1(a3)
 37a:	bf69                	j	314 <_write.constprop.0+0x62>
 37c:	4481                	li	s1,0
 37e:	bff1                	j	35a <_write.constprop.0+0xa8>

00000380 <__puts_uart>:
{
 380:	1161                	addi	sp,sp,-8
 382:	c022                	sw	s0,0(sp)
 384:	c206                	sw	ra,4(sp)
 386:	842e                	mv	s0,a1
	_write( 0, s, len );
 388:	372d                	jal	2b2 <_write.constprop.0>
}
 38a:	4092                	lw	ra,4(sp)
 38c:	8522                	mv	a0,s0
 38e:	4402                	lw	s0,0(sp)
 390:	0121                	addi	sp,sp,8
 392:	8082                	ret

00000394 <handle_reset>:
	asm volatile( "\n\
 394:	20000197          	auipc	gp,0x20000
 398:	46c18193          	addi	gp,gp,1132 # 20000800 <__global_pointer$>
 39c:	00018113          	mv	sp,gp
 3a0:	08000513          	li	a0,128
 3a4:	30051073          	csrw	mstatus,a0
 3a8:	468d                	li	a3,3
 3aa:	00000517          	auipc	a0,0x0
 3ae:	c5650513          	addi	a0,a0,-938 # 0 <InterruptVector>
 3b2:	8d55                	or	a0,a0,a3
 3b4:	30551073          	csrw	mtvec,a0
asm volatile(
 3b8:	80418513          	addi	a0,gp,-2044 # 20000004 <_ebss>
 3bc:	80418593          	addi	a1,gp,-2044 # 20000004 <_ebss>
 3c0:	4601                	li	a2,0
 3c2:	00b55663          	bge	a0,a1,3ce <handle_reset+0x3a>
 3c6:	c110                	sw	a2,0(a0)
 3c8:	0511                	addi	a0,a0,4
 3ca:	feb54ee3          	blt	a0,a1,3c6 <handle_reset+0x32>
 3ce:	7f000513          	li	a0,2032
 3d2:	20000597          	auipc	a1,0x20000
 3d6:	c2e58593          	addi	a1,a1,-978 # 20000000 <C.0.0>
 3da:	80418613          	addi	a2,gp,-2044 # 20000004 <_ebss>
 3de:	00c58863          	beq	a1,a2,3ee <handle_reset+0x5a>
 3e2:	4114                	lw	a3,0(a0)
 3e4:	c194                	sw	a3,0(a1)
 3e6:	0511                	addi	a0,a0,4
 3e8:	0591                	addi	a1,a1,4
 3ea:	fec59ae3          	bne	a1,a2,3de <handle_reset+0x4a>
	SysTick->CTLR = 1;
 3ee:	e000f7b7          	lui	a5,0xe000f
 3f2:	4705                	li	a4,1
 3f4:	c398                	sw	a4,0(a5)
asm volatile(
 3f6:	4781                	li	a5,0
 3f8:	77800793          	li	a5,1912
 3fc:	34179073          	csrw	mepc,a5
 400:	30200073          	mret

00000404 <ADC1_IRQHandler>:
	asm volatile( "1: j 1b" );
 404:	a001                	j	404 <ADC1_IRQHandler>

00000406 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 406:	40021737          	lui	a4,0x40021
 40a:	471c                	lw	a5,8(a4)
 40c:	008006b7          	lui	a3,0x800
 410:	8fd5                	or	a5,a5,a3
 412:	c71c                	sw	a5,8(a4)

00000414 <strlen>:
WEAK size_t strlen(const char *s) { const char *a = s;for (; *s; s++);return s-a; }
 414:	87aa                	mv	a5,a0
 416:	0007c703          	lbu	a4,0(a5) # e000f000 <__global_pointer$+0xc000e800>
 41a:	e701                	bnez	a4,422 <strlen+0xe>
 41c:	40a78533          	sub	a0,a5,a0
 420:	8082                	ret
 422:	0785                	addi	a5,a5,1
 424:	bfcd                	j	416 <strlen+0x2>

00000426 <mini_vpprintf>:
{
 426:	fa410113          	addi	sp,sp,-92
 42a:	caa2                	sw	s0,84(sp)
 42c:	c8a6                	sw	s1,80(sp)
 42e:	cc86                	sw	ra,88(sp)
 430:	c02a                	sw	a0,0(sp)
 432:	c22e                	sw	a1,4(sp)
 434:	8432                	mv	s0,a2
 436:	84b6                	mv	s1,a3
	if(puts == (void*)0) {
 438:	e509                	bnez	a0,442 <mini_vpprintf+0x1c>
		puts = _puts; buf = (void*)0;
 43a:	1a800793          	li	a5,424
 43e:	c202                	sw	zero,4(sp)
 440:	c03e                	sw	a5,0(sp)
	int n = 0;
 442:	ca02                	sw	zero,20(sp)
	while ((ch=*(fmt++))) {
 444:	00044783          	lbu	a5,0(s0)
 448:	00140713          	addi	a4,s0,1
 44c:	00f10fa3          	sb	a5,31(sp)
 450:	eb81                	bnez	a5,460 <mini_vpprintf+0x3a>
}
 452:	40e6                	lw	ra,88(sp)
 454:	4456                	lw	s0,84(sp)
 456:	4552                	lw	a0,20(sp)
 458:	44c6                	lw	s1,80(sp)
 45a:	05c10113          	addi	sp,sp,92
 45e:	8082                	ret
 460:	c63a                	sw	a4,12(sp)
		if (ch!='%') {
 462:	02500693          	li	a3,37
 466:	02d78063          	beq	a5,a3,486 <mini_vpprintf+0x60>
			len = puts(&ch, len, buf);
 46a:	4612                	lw	a2,4(sp)
 46c:	4782                	lw	a5,0(sp)
 46e:	4585                	li	a1,1
 470:	01f10513          	addi	a0,sp,31
 474:	9782                	jalr	a5
	while ((ch=*(fmt++))) {
 476:	4732                	lw	a4,12(sp)
 478:	c426                	sw	s1,8(sp)
 47a:	843a                	mv	s0,a4
		n = n + len;
 47c:	47d2                	lw	a5,20(sp)
 47e:	44a2                	lw	s1,8(sp)
 480:	97aa                	add	a5,a5,a0
 482:	ca3e                	sw	a5,20(sp)
 484:	b7c1                	j	444 <mini_vpprintf+0x1e>
			ch=*(fmt++);
 486:	00144783          	lbu	a5,1(s0)
			if (ch == '0') pad_char = '0';
 48a:	03000693          	li	a3,48
			ch=*(fmt++);
 48e:	00240713          	addi	a4,s0,2
 492:	00f10fa3          	sb	a5,31(sp)
			if (ch == '0') pad_char = '0';
 496:	c63e                	sw	a5,12(sp)
 498:	08d79363          	bne	a5,a3,51e <mini_vpprintf+0xf8>
				ch=*(fmt++);
 49c:	843a                	mv	s0,a4
 49e:	4681                	li	a3,0
 4a0:	4701                	li	a4,0
			while (ch >= '0' && ch <= '9') {
 4a2:	45a5                	li	a1,9
 4a4:	a819                	j	4ba <mini_vpprintf+0x94>
				pad_to = pad_to * 10 + (ch - '0');
 4a6:	00271793          	slli	a5,a4,0x2
 4aa:	97ba                	add	a5,a5,a4
 4ac:	0786                	slli	a5,a5,0x1
				ch=*(fmt++);
 4ae:	0405                	addi	s0,s0,1
				pad_to = pad_to * 10 + (ch - '0');
 4b0:	00f60733          	add	a4,a2,a5
				ch=*(fmt++);
 4b4:	fff44783          	lbu	a5,-1(s0)
 4b8:	4685                	li	a3,1
			while (ch >= '0' && ch <= '9') {
 4ba:	fd078613          	addi	a2,a5,-48
 4be:	0ff67513          	zext.b	a0,a2
 4c2:	fea5f2e3          	bgeu	a1,a0,4a6 <mini_vpprintf+0x80>
 4c6:	c299                	beqz	a3,4cc <mini_vpprintf+0xa6>
 4c8:	00f10fa3          	sb	a5,31(sp)
			if(pad_to > (signed int) sizeof(bf)) {
 4cc:	c83a                	sw	a4,16(sp)
 4ce:	46e1                	li	a3,24
 4d0:	00e6d363          	bge	a3,a4,4d6 <mini_vpprintf+0xb0>
 4d4:	c836                	sw	a3,16(sp)
			if (ch == 'l') {
 4d6:	06c00613          	li	a2,108
			char l = 0;
 4da:	4681                	li	a3,0
			if (ch == 'l') {
 4dc:	00c79863          	bne	a5,a2,4ec <mini_vpprintf+0xc6>
				ch=*(fmt++);
 4e0:	00044783          	lbu	a5,0(s0)
				l = 1;
 4e4:	4685                	li	a3,1
				ch=*(fmt++);
 4e6:	0405                	addi	s0,s0,1
 4e8:	00f10fa3          	sb	a5,31(sp)
			switch (ch) {
 4ec:	01f14603          	lbu	a2,31(sp)
 4f0:	06400793          	li	a5,100
 4f4:	06f60563          	beq	a2,a5,55e <mini_vpprintf+0x138>
 4f8:	02c7e763          	bltu	a5,a2,526 <mini_vpprintf+0x100>
 4fc:	05800793          	li	a5,88
 500:	0af60063          	beq	a2,a5,5a0 <mini_vpprintf+0x17a>
 504:	06300793          	li	a5,99
 508:	0af60d63          	beq	a2,a5,5c2 <mini_vpprintf+0x19c>
 50c:	d239                	beqz	a2,452 <mini_vpprintf+0x2c>
					len = puts(&ch, len, buf);
 50e:	4612                	lw	a2,4(sp)
 510:	4782                	lw	a5,0(sp)
 512:	4585                	li	a1,1
 514:	01f10513          	addi	a0,sp,31
 518:	9782                	jalr	a5
					break;
 51a:	c426                	sw	s1,8(sp)
 51c:	b785                	j	47c <mini_vpprintf+0x56>
			char pad_char = ' ';
 51e:	02000693          	li	a3,32
 522:	c636                	sw	a3,12(sp)
 524:	bfa5                	j	49c <mini_vpprintf+0x76>
			switch (ch) {
 526:	07500793          	li	a5,117
 52a:	02f60a63          	beq	a2,a5,55e <mini_vpprintf+0x138>
 52e:	07800793          	li	a5,120
 532:	06f60763          	beq	a2,a5,5a0 <mini_vpprintf+0x17a>
 536:	07300793          	li	a5,115
 53a:	fcf61ae3          	bne	a2,a5,50e <mini_vpprintf+0xe8>
					ptr = va_arg(va, char*);
 53e:	00448793          	addi	a5,s1,4
 542:	4084                	lw	s1,0(s1)
 544:	cc3a                	sw	a4,24(sp)
 546:	c43e                	sw	a5,8(sp)
					len = mini_strlen(ptr);
 548:	8526                	mv	a0,s1
 54a:	35e9                	jal	414 <strlen>
					if (pad_to > 0) {
 54c:	4762                	lw	a4,24(sp)
					len = mini_strlen(ptr);
 54e:	85aa                	mv	a1,a0
					if (pad_to > 0) {
 550:	08e05663          	blez	a4,5dc <mini_vpprintf+0x1b6>
						len = mini_pad(ptr, len, pad_char, pad_to, bf);
 554:	46c2                	lw	a3,16(sp)
 556:	4632                	lw	a2,12(sp)
 558:	1838                	addi	a4,sp,56
 55a:	8526                	mv	a0,s1
 55c:	a01d                	j	582 <mini_vpprintf+0x15c>
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 55e:	00448793          	addi	a5,s1,4
 562:	c43e                	sw	a5,8(sp)
					if(l) {
 564:	c695                	beqz	a3,590 <mini_vpprintf+0x16a>
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 566:	f8b60613          	addi	a2,a2,-117
 56a:	1018                	addi	a4,sp,32
 56c:	00163693          	seqz	a3,a2
 570:	4088                	lw	a0,0(s1)
 572:	4601                	li	a2,0
 574:	45a9                	li	a1,10
 576:	398d                	jal	1e8 <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 578:	46c2                	lw	a3,16(sp)
 57a:	4632                	lw	a2,12(sp)
 57c:	1838                	addi	a4,sp,56
 57e:	85aa                	mv	a1,a0
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 580:	1008                	addi	a0,sp,32
 582:	3e71                	jal	11e <mini_pad>
					len = puts(bf, len, buf);
 584:	4612                	lw	a2,4(sp)
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 586:	85aa                	mv	a1,a0
					len = puts(bf, len, buf);
 588:	1828                	addi	a0,sp,56
 58a:	4782                	lw	a5,0(sp)
 58c:	9782                	jalr	a5
					break;
 58e:	b5fd                	j	47c <mini_vpprintf+0x56>
						if(ch == 'u') {
 590:	07500793          	li	a5,117
 594:	1018                	addi	a4,sp,32
 596:	4685                	li	a3,1
 598:	fcf60ce3          	beq	a2,a5,570 <mini_vpprintf+0x14a>
	if (radix > 16)
 59c:	4681                	li	a3,0
 59e:	bfc9                	j	570 <mini_vpprintf+0x14a>
					if(l) {
 5a0:	4088                	lw	a0,0(s1)
						len = mini_itoa(va_arg(va, unsigned long), 16, (ch=='X'), 1, bf2);
 5a2:	fa860613          	addi	a2,a2,-88
						len = mini_itoa(va_arg(va, unsigned long), 10, 0, (ch=='u'), bf2);
 5a6:	00448793          	addi	a5,s1,4
 5aa:	1018                	addi	a4,sp,32
 5ac:	4685                	li	a3,1
 5ae:	00163613          	seqz	a2,a2
 5b2:	45c1                	li	a1,16
 5b4:	c43e                	sw	a5,8(sp)
	if (radix > 16)
 5b6:	390d                	jal	1e8 <mini_itoa.part.0>
					len = mini_pad(bf2, len, pad_char, pad_to, bf);
 5b8:	46c2                	lw	a3,16(sp)
 5ba:	4632                	lw	a2,12(sp)
 5bc:	85aa                	mv	a1,a0
 5be:	1838                	addi	a4,sp,56
 5c0:	b7c1                	j	580 <mini_vpprintf+0x15a>
					ch = (char)(va_arg(va, int));
 5c2:	00448793          	addi	a5,s1,4
 5c6:	c43e                	sw	a5,8(sp)
 5c8:	409c                	lw	a5,0(s1)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 5ca:	46c2                	lw	a3,16(sp)
 5cc:	4632                	lw	a2,12(sp)
					ch = (char)(va_arg(va, int));
 5ce:	00f10fa3          	sb	a5,31(sp)
					len = mini_pad(&ch, 1, pad_char, pad_to, bf);
 5d2:	1838                	addi	a4,sp,56
 5d4:	4585                	li	a1,1
 5d6:	01f10513          	addi	a0,sp,31
 5da:	b765                	j	582 <mini_vpprintf+0x15c>
						len = puts(ptr, len, buf);
 5dc:	4612                	lw	a2,4(sp)
 5de:	8526                	mv	a0,s1
 5e0:	b76d                	j	58a <mini_vpprintf+0x164>

000005e2 <printf>:
{
 5e2:	1111                	addi	sp,sp,-28
 5e4:	c632                	sw	a2,12(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 5e6:	862a                	mv	a2,a0
{
 5e8:	c42e                	sw	a1,8(sp)
 5ea:	c836                	sw	a3,16(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 5ec:	4581                	li	a1,0
	va_start( args, format );
 5ee:	0034                	addi	a3,sp,8
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 5f0:	38000513          	li	a0,896
{
 5f4:	c206                	sw	ra,4(sp)
 5f6:	ca3a                	sw	a4,20(sp)
 5f8:	cc3e                	sw	a5,24(sp)
	va_start( args, format );
 5fa:	c036                	sw	a3,0(sp)
	int ret_status = mini_vpprintf(__puts_uart, 0, format, args);
 5fc:	352d                	jal	426 <mini_vpprintf>
}
 5fe:	4092                	lw	ra,4(sp)
 600:	0171                	addi	sp,sp,28
 602:	8082                	ret

00000604 <move_to_endpoint>:
	uint32_t mask = x >> 31; // Extract the sign bit
	return (x ^ mask) - mask;
}

void move_to_endpoint(const position_t endpoint)
{
 604:	fc810113          	addi	sp,sp,-56
 608:	d626                	sw	s1,44(sp)
 60a:	84aa                	mv	s1,a0
 60c:	04c2                	slli	s1,s1,0x10
 60e:	84c1                	srai	s1,s1,0x10
	uint32_t mask = x >> 31; // Extract the sign bit
 610:	41f4d793          	srai	a5,s1,0x1f
	return (x ^ mask) - mask;
 614:	00f4c6b3          	xor	a3,s1,a5
 618:	41055293          	srai	t0,a0,0x10
 61c:	8e9d                	sub	a3,a3,a5
	// Bresenham variables
	// Delta x and y - total distances to cover in x and y direction
	int32_t x_delta = int_abs(endpoint.x - startpoint.x);
	int32_t y_delta = int_abs(endpoint.y - startpoint.y);
	// Which direction to step in
	int32_t x_step = (startpoint.x < endpoint.x)  ?  1 : -1;
 61e:	0014a793          	slti	a5,s1,1
{
 622:	d822                	sw	s0,48(sp)
	int32_t x_step = (startpoint.x < endpoint.x)  ?  1 : -1;
 624:	40f007b3          	neg	a5,a5
	int32_t y_step = (startpoint.y < endpoint.y)  ?  1 : -1;
 628:	0012a413          	slti	s0,t0,1
	int32_t x_step = (startpoint.x < endpoint.x)  ?  1 : -1;
 62c:	0017e793          	ori	a5,a5,1
	int32_t y_step = (startpoint.y < endpoint.y)  ?  1 : -1;
 630:	40800433          	neg	s0,s0
	int32_t x_step = (startpoint.x < endpoint.x)  ?  1 : -1;
 634:	c03e                	sw	a5,0(sp)
	int32_t y_step = (startpoint.y < endpoint.y)  ?  1 : -1;
 636:	00146793          	ori	a5,s0,1
 63a:	c23e                	sw	a5,4(sp)
 63c:	4782                	lw	a5,0(sp)
	uint32_t mask = x >> 31; // Extract the sign bit
 63e:	857d                	srai	a0,a0,0x1f
	return (x ^ mask) - mask;
 640:	00a2c633          	xor	a2,t0,a0
 644:	8e09                	sub	a2,a2,a0
{
 646:	da06                	sw	ra,52(sp)
 648:	17fd                	addi	a5,a5,-1
	// Accumulated Error - how far from the ideal line we are
	int32_t err = x_delta - y_delta;
 64a:	40c68733          	sub	a4,a3,a2


	// Step through the line until the destination is reached
	while(startpoint.x != endpoint.x || startpoint.y != endpoint.y) 
 64e:	eb85                	bnez	a5,67e <move_to_endpoint+0x7a>
 650:	4781                	li	a5,0
 652:	7b400793          	li	a5,1972
 656:	c43e                	sw	a5,8(sp)
 658:	4792                	lw	a5,4(sp)
 65a:	17fd                	addi	a5,a5,-1
 65c:	e78d                	bnez	a5,686 <move_to_endpoint+0x82>
 65e:	4781                	li	a5,0
 660:	7c400793          	li	a5,1988
 664:	c63e                	sw	a5,12(sp)
	position_t startpoint = {0, 0};
 666:	4401                	li	s0,0
 668:	4301                	li	t1,0
	while(startpoint.x != endpoint.x || startpoint.y != endpoint.y) 
 66a:	02931263          	bne	t1,s1,68e <move_to_endpoint+0x8a>
 66e:	02829063          	bne	t0,s0,68e <move_to_endpoint+0x8a>

			// TODO:
			printf("Step: %s\n", (y_step > 0) ? "up" : "down");
		}
	}
}
 672:	50d2                	lw	ra,52(sp)
 674:	5442                	lw	s0,48(sp)
 676:	54b2                	lw	s1,44(sp)
 678:	03810113          	addi	sp,sp,56
 67c:	8082                	ret
 67e:	4781                	li	a5,0
 680:	7bc00793          	li	a5,1980
 684:	bfc9                	j	656 <move_to_endpoint+0x52>
 686:	4781                	li	a5,0
 688:	7c800793          	li	a5,1992
 68c:	bfe1                	j	664 <move_to_endpoint+0x60>
		int32_t err2 = err * 2;
 68e:	00171393          	slli	t2,a4,0x1
		if(err2 > -y_delta)
 692:	40c005b3          	neg	a1,a2
 696:	0275d963          	bge	a1,t2,6c8 <move_to_endpoint+0xc4>
			startpoint.x += x_step;
 69a:	4782                	lw	a5,0(sp)
			printf("Step: %s\n", (x_step > 0) ? "right" : "left");
 69c:	45a2                	lw	a1,8(sp)
 69e:	4501                	li	a0,0
			startpoint.x += x_step;
 6a0:	933e                	add	t1,t1,a5
 6a2:	0342                	slli	t1,t1,0x10
			err -= y_delta;
 6a4:	8f11                	sub	a4,a4,a2
			startpoint.x += x_step;
 6a6:	41035313          	srai	t1,t1,0x10
			printf("Step: %s\n", (x_step > 0) ? "right" : "left");
 6aa:	7d000513          	li	a0,2000
 6ae:	d216                	sw	t0,36(sp)
 6b0:	d01e                	sw	t2,32(sp)
 6b2:	ce36                	sw	a3,28(sp)
			err -= y_delta;
 6b4:	cc32                	sw	a2,24(sp)
 6b6:	ca3a                	sw	a4,20(sp)
			startpoint.x += x_step;
 6b8:	c81a                	sw	t1,16(sp)
			printf("Step: %s\n", (x_step > 0) ? "right" : "left");
 6ba:	3725                	jal	5e2 <printf>
 6bc:	5292                	lw	t0,36(sp)
 6be:	5382                	lw	t2,32(sp)
 6c0:	46f2                	lw	a3,28(sp)
 6c2:	4662                	lw	a2,24(sp)
 6c4:	4752                	lw	a4,20(sp)
 6c6:	4342                	lw	t1,16(sp)
		if(err2 < x_delta) 
 6c8:	fad3d1e3          	bge	t2,a3,66a <move_to_endpoint+0x66>
			startpoint.y += y_step;
 6cc:	4792                	lw	a5,4(sp)
			printf("Step: %s\n", (y_step > 0) ? "up" : "down");
 6ce:	45b2                	lw	a1,12(sp)
 6d0:	4501                	li	a0,0
			err += x_delta;
 6d2:	9736                	add	a4,a4,a3
			startpoint.y += y_step;
 6d4:	97a2                	add	a5,a5,s0
			printf("Step: %s\n", (y_step > 0) ? "up" : "down");
 6d6:	7d000513          	li	a0,2000
 6da:	d016                	sw	t0,32(sp)
 6dc:	ce1a                	sw	t1,28(sp)
 6de:	cc32                	sw	a2,24(sp)
			err += x_delta;
 6e0:	ca36                	sw	a3,20(sp)
 6e2:	c83a                	sw	a4,16(sp)
			startpoint.y += y_step;
 6e4:	01079413          	slli	s0,a5,0x10
			printf("Step: %s\n", (y_step > 0) ? "up" : "down");
 6e8:	3ded                	jal	5e2 <printf>
 6ea:	5282                	lw	t0,32(sp)
 6ec:	4372                	lw	t1,28(sp)
 6ee:	4662                	lw	a2,24(sp)
 6f0:	46d2                	lw	a3,20(sp)
 6f2:	4742                	lw	a4,16(sp)
			startpoint.y += y_step;
 6f4:	8441                	srai	s0,s0,0x10
			printf("Step: %s\n", (y_step > 0) ? "up" : "down");
 6f6:	bf95                	j	66a <move_to_endpoint+0x66>

000006f8 <puts>:
{
 6f8:	1151                	addi	sp,sp,-12
 6fa:	c406                	sw	ra,8(sp)
 6fc:	c222                	sw	s0,4(sp)
 6fe:	c026                	sw	s1,0(sp)
 700:	84aa                	mv	s1,a0
	int sl = strlen( s );
 702:	3b09                	jal	414 <strlen>
 704:	842a                	mv	s0,a0
	_write(0, s, sl );
 706:	85aa                	mv	a1,a0
 708:	8526                	mv	a0,s1
 70a:	3665                	jal	2b2 <_write.constprop.0>
	_write(0, "\n", 1 );
 70c:	4501                	li	a0,0
 70e:	4585                	li	a1,1
 710:	7d800513          	li	a0,2008
 714:	3e79                	jal	2b2 <_write.constprop.0>
}
 716:	40a2                	lw	ra,8(sp)
 718:	00140513          	addi	a0,s0,1
 71c:	4412                	lw	s0,4(sp)
 71e:	4482                	lw	s1,0(sp)
 720:	0131                	addi	sp,sp,12
 722:	8082                	ret

00000724 <SystemInit>:
	// CH32V003 flash latency
#if defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 724:	400227b7          	lui	a5,0x40022
 728:	4705                	li	a4,1
 72a:	c398                	sw	a4,0(a5)
#if defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 72c:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 730:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 734:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 738:	08170713          	addi	a4,a4,129 # 1080081 <insomniac.c.2101b6a3+0x107e2c2>
 73c:	c398                	sw	a4,0(a5)
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 73e:	009f0737          	lui	a4,0x9f0
 742:	c798                	sw	a4,8(a5)

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 744:	4398                	lw	a4,0(a5)
 746:	00671693          	slli	a3,a4,0x6
 74a:	fe06dde3          	bgez	a3,744 <SystemInit+0x20>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 74e:	43d8                	lw	a4,4(a5)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 750:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 754:	9b71                	andi	a4,a4,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 756:	00276713          	ori	a4,a4,2
 75a:	c3d8                	sw	a4,4(a5)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 75c:	4721                	li	a4,8
 75e:	42dc                	lw	a5,4(a3)
 760:	8bb1                	andi	a5,a5,12
 762:	fee79ee3          	bne	a5,a4,75e <SystemInit+0x3a>
	*DMDATA1 = 0x0;
 766:	e00007b7          	lui	a5,0xe0000
 76a:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
	*DMDATA0 = 0x80;
 76e:	08000713          	li	a4,128
 772:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 776:	8082                	ret

00000778 <main>:
{
 778:	1151                	addi	sp,sp,-12
 77a:	c406                	sw	ra,8(sp)
	SystemInit();
 77c:	3765                	jal	724 <SystemInit>
	printf("5,0\n");
 77e:	4501                	li	a0,0
 780:	7dc00513          	li	a0,2012
 784:	3f95                	jal	6f8 <puts>
	move_to_endpoint( (const position_t){-5, 0});
 786:	6541                	lui	a0,0x10
 788:	156d                	addi	a0,a0,-5 # fffb <insomniac.c.2101b6a3+0xe23c>
 78a:	3dad                	jal	604 <move_to_endpoint>
	printf("\n\n0,5\n");
 78c:	4501                	li	a0,0
 78e:	7e000513          	li	a0,2016
 792:	379d                	jal	6f8 <puts>
	move_to_endpoint( (const position_t){0, -5});
 794:	fffb0537          	lui	a0,0xfffb0
 798:	35b5                	jal	604 <move_to_endpoint>
	printf("\n\n5,5\n");
 79a:	4501                	li	a0,0
 79c:	7e800513          	li	a0,2024
 7a0:	3fa1                	jal	6f8 <puts>
	move_to_endpoint( (const position_t){-5, -5});
 7a2:	200007b7          	lui	a5,0x20000
 7a6:	0007a503          	lw	a0,0(a5) # 20000000 <C.0.0>
 7aa:	3da9                	jal	604 <move_to_endpoint>
}
 7ac:	40a2                	lw	ra,8(sp)
 7ae:	4501                	li	a0,0
 7b0:	0131                	addi	sp,sp,12
 7b2:	8082                	ret
 7b4:	6972                	.insn	2, 0x6972
 7b6:	00746867          	.insn	4, 0x00746867
 7ba:	0000                	unimp
 7bc:	656c                	.insn	2, 0x656c
 7be:	7466                	.insn	2, 0x7466
 7c0:	0000                	unimp
 7c2:	0000                	unimp
 7c4:	7075                	c.lui	zero,0xffffd
 7c6:	0000                	unimp
 7c8:	6f64                	.insn	2, 0x6f64
 7ca:	00006e77          	.insn	4, 0x6e77
 7ce:	0000                	unimp
 7d0:	70657453          	.insn	4, 0x70657453
 7d4:	203a                	.insn	2, 0x203a
 7d6:	7325                	lui	t1,0xfffe9
 7d8:	000a                	c.slli	zero,0x2
 7da:	0000                	unimp
 7dc:	2c35                	jal	a18 <_data_lma+0x228>
 7de:	0030                	addi	a2,sp,8
 7e0:	0a0a                	slli	s4,s4,0x2
 7e2:	2c30                	.insn	2, 0x2c30
 7e4:	0035                	c.nop	13
 7e6:	0000                	unimp
 7e8:	0a0a                	slli	s4,s4,0x2
 7ea:	2c35                	jal	a26 <_data_lma+0x236>
 7ec:	0035                	c.nop	13
	...
